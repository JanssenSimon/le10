-1. UI redesign de Jej (ajouter des couleurs,
                        ajuster les teintes,
                        police de cartes custom,
                        mettre la levée des 4 dernières cartes jouées proche du gagnant)
0. Demander confirmation pour données importantes comme le nom
   noms uniques
   augmenter délai à la suite d'un round.
   reset le jeu après 4 déconnections seulement quand tout le monde aura déconnecté
   vérifier condition de victoire, faire un écran de victoire
1. envoyer des messages relevant à certains joueurs à des moments relevant
   exemple: quand iel joue un carte illégale, envoyer un message comme quoi on peut pas
                jouer cte carte la et pourquoi
2. ajouter IAs
3. Cleanup the stinky code (EW GROSS)
4. ajouter plusieurs salles de jeu et fix la queue
5. mettre à jour aria-descriptions (TRES IMPORTANT)
6. penser à facon de joindre une salle spécifique.et de choisir un siege specifique








Implementing state machine for server:

general description:
- the server will contain a state machine associated to every websocket
- the states of the state machine will store what state of the game the user on
  the other side of the websocket is on (inputing their name/selecting a game/
  currently in a game).
- the state a websocket is in will determine the set of messages the server
  accepts from it and parses, it determines what should be included in a
  message the server receives from the websocket
- for every state, there exist validator functions which decide whether a
  received message is valid. if the validator cannot validate the message, the
  next validator will try and so on until there are no more validators and the
  server calls an error function
- the error function of a websocket will typically send an error message to the
  websocket in order to give feedback to the client as to why their message
  wasn't accepted
- if a valid message is received, a function associated with the form of that
  message will be called. these functions can change the state that the
  websocket is associated with

we can describe this state machine in a JSON file:
{
  startstate: {
    name: "Name of state",
    methods: [
      {
        validator: validatorFunction1,
        method: method1,
        nextState: "Name of next state"
      },
      {
        validator: validatorFunction2,
        method: method2
        nextState: "Name of state"          //No change in state
      }
    ],
    error: errorFunction
  },
  intermediatestates: [
    {
      name: "NameSelection",
      methods: [
        {
          validator: isMessageName,
          method: recordName,
          nextState: "GameSelection"
        }
      ],
      error: nameSelectionErrorFunction
    },
    {
      name: "GameSelection",
      methods: [
        {
          validator: isMessageName,
          method: recordName,
          nextState: "GameSelection"
        },
        {
          validator: isGameChoice,
          method: joinGame,
          nextState: "InGame"
        }
      ],
      error: gameSelectionErrorFunction
    },
    {
      name: "InGame",
      methods: [
        {
          validator: isBet,
          method: bet,
          nextState: "InGame"
        },
        {
          validator: isCardChoice,
          method: playCard,
          nextState: "InGame"
        },
        {
          validator: isExitGame,
          method: exitGame,
          nextState: "GameSelection"
        }
      ],
      error: inGameErrorFunction
    }
  ]
}

In fact, it should just be a regular old javascript file that contains the
state machine object and the functions it contains.
